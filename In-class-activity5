class Node(object):
    '''This class represents a single Node.'''

    def __init__(self, data):
        self.data = data
        self.lChild = None
        self.rChild = None

    def print_node(self, level=0):

        if self.lChild != None:
            self.lChild.print_node(level + 1)

        print(' ' * 4 * level + '->', self.data)

        if self.rChild != None:
            self.rChild.print_node(level + 1)
            
    def size(self):
        if self == None:
            return 0
        total = 1
        if self.lChild != None:
            total += self.lChild.size()
        if self.rChild != None:
            total += self.rChild.size()
        return total
        


class BST(object):
    '''This class represents a Binary Search Tree.'''

    def __init__(self):
        self.root = None

    def print(self, level):
        self.root.print_node(level)

    # Search for a node with the key
    def search(self, key):
        current = self.root
        while ((current != None) and (current.data != key)):
            if (key < current.data):
                current = current.lChild
            else:
                current = current.rChild
            return current

    # Insert a node in the tree
    def insert(self, val):
        newNode = Node(val)

        if (self.root == None):
            self.root = newNode
        else:
            current = self.root
            parent = self.root

            while (current != None):
                parent = current
                if (val < current.data):
                    current = current.lChild
                else:
                    current = current.rChild

            if (val < parent.data):
                parent.lChild = newNode
            else:
                parent.rChild = newNode

    # In order traversal - left, center, right
    def inOrder(self, aNode):
        if (aNode != None):
            print(aNode.data)
            aNode.inOrder(aNode.lChild)
            aNode.inOrder(aNode.rChild)

    # Pre order traversal - center, left, right
    def preOrder(self, aNode):
        if (aNode != None):
            print(aNode.data)
            aNode.preOrder(aNode.lChild)
            aNode.preOrder(aNode.rChild)

    # Post order traversal - left, right, center
    def postOrder(self, aNode):
        if (aNode != None):
            print(aNode.data)
            aNode.postOrder(aNode.lChild)
            aNode.postOrder(aNode.rChild)

    # Find the node with the smallest value
    def minimum(self):
        current = self.root
        parent = current
        while (current != None):
            parent = current
            current = current.lChild
        return parent

    # Find the node with the largest value
    def maximum(self):
        current = self.root
        parent = current
        while (current != None):
            parent = current
            current = current.rChild
        return parent

    # Delete a node with a given key
    def delete(self, key):
        deleteNode = self.root
        parent = self.root
        isLeft = False

        # If empty tree
        if (deleteNode == None):
            return False

        # Find the delete node
        while ((deleteNode != None) and (deleteNode.data != key)):
            parent = deleteNode
            if (key < deleteNode.data):
                deleteNode = deleteNode.lChild
                isLeft = True
            else:
                deleteNode = deleteNode.rChild
                isLeft = False

        # If node not found
        if (deleteNode == None):
            return False

        # Delete node is a leaf node
        if ((deleteNode.lChild == None) and (deleteNode.rChild == None)):
            if (deleteNode == self.root):
                self.root = None
            elif (isLeft):
                parent.lChild = None
            else:
                parent.rChild = None

        # Delete node is a node with only left child
        elif (deleteNode.rChild == None):
            if (deleteNode == self.root):
                self.root = deleteNode.lChild
            elif (isLeft):
                parent.lChild = deleteNode.lChild
            else:
                parent.rChild = deleteNode.lChild

        # Delete node is a node with only right child
        elif (deleteNode.lChild == None):
            if (deleteNode == self.root):
                self.root = deleteNode.rChild
            elif (isLeft):
                parent.lChild = deleteNode.rChild
            else:
                parent.rChild = deleteNode.rChild

        # Delete node is a node with both left and right child
        else:
            # Find delete node's successor and successor's parent nodes
            successor = deleteNode.rChild
            successorParent = deleteNode

            while (successor.lChild != None):
                successorParent = successor

                successor = successor.lChild

            # Successor node right child of delete node
            if (deleteNode == self.root):
                self.root = successor
            elif (isLeft):
                parent.lChild = successor
            else:
                parent.rChild = successor

            # Connect delete node's left child to be successor's left child
            successor.lChild = deleteNode.lChild

            # Successor node left descendant of delete node
            if (successor != deleteNode.rChild):
                successorParent.lChild = successor.rChild

                successor.rChild = deleteNode.rChild

        return True
        
    def size(self):
        if self.root is None:
            return 0
        else:
            return self.root.size()

    def findMedian(self):
        totalsize = self.size()
        if totalsize %2 == 0:
            return self.finddata(self.root,totalsize/2)/2 + self.finddata(self.root,totalsize/2+1)/2
        else:
            return self.finddata(self.root,totalsize/2)
    def finddata(self,node,nums):
        if node.lChild != None:
            left = node.lChild.size()
        else:
            left = 0
        if left < nums -1:
            return self.finddata(node.rChild,nums-left-1)
        elif left == nums -1:
            return node.data
        else:
            return self.finddata(node.lChild,nums)
        
    def heighthp(self, node):
        if node is None:
            return 0
        return max(self.heighthp(node.lChild), self.heighthp(node.rChild))+1
    def height(self):
        return self.heighthp(self.root)   
    
    def isBalancedhp(self,root):
 
        # Base condition
        if root is None:
            return True
    
        # for left and right subtree height
        lh = self.heighthp(root.lChild)
        rh = self.heighthp(root.rChild)
    
        # allowed values for (lh - rh) are 1, -1, 0
        if (abs(lh - rh) <= 1) and self.isBalanced(
                root.lChild) is True and self.isBalanced(root.rChild) is True:
            return True
    
        # if we reach here means tree is not
        # height-balanced tree
        return False
    def isBalanced(self):
        return self.isBalancedhp(self.root)

###############################
#                             #
#   Example run of a BST run  #
#                             #
###############################

def main():
    bst = BST()
    print(bst.size())
    bst.insert(10)
    bst.insert(40)
    bst.insert(5)
    bst.insert(45)
    bst.insert(30)
    bst.insert(35)
    print(bst.size())
    print(bst.height())
    print(bst.isBalanced())
    print(bst.findMedian())
    bst.print(2)
    bst.delete(10)
    print(bst.height())
    print(bst.size())


if __name__ == '__main__':
    main()
